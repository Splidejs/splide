{"version":3,"file":"splide-renderer.min.js","sources":["../../../utils/dist/splide-utils.esm.js","../../src/js/components/Direction/Direction.ts","../../src/js/constants/arrows.ts","../../src/js/constants/directions.ts","../../src/js/constants/project.ts","../../src/js/constants/classes.ts","../../src/js/constants/defaults.ts","../../src/js/constants/i18n.ts","../../src/js/renderer/constants/defaults.ts","../../src/js/renderer/Style/Style.ts","../../src/js/utils/error/assert/assert.ts","../../src/js/renderer/SplideRenderer/SplideRenderer.ts","../../src/js/constants/events.ts","../../src/js/constants/types.ts","../../src/js/renderer/constants/classes.ts","../../src/js/components/Arrows/path.ts"],"sourcesContent":["function empty(array) {\n  array.length = 0;\n}\nfunction apply(func, ...args) {\n  return func.bind(null, ...args);\n}\nconst nextTick = setTimeout;\nconst noop = () => {\n};\nfunction raf(func) {\n  return requestAnimationFrame(func);\n}\nfunction typeOf(type, subject) {\n  return typeof subject === type;\n}\nfunction isObject(subject) {\n  return !isNull(subject) && typeOf(\"object\", subject);\n}\nconst isArray = Array.isArray;\nconst isFunction = apply(typeOf, \"function\");\nconst isString = apply(typeOf, \"string\");\nconst isBoolean = apply(typeOf, \"boolean\");\nconst isUndefined = apply(typeOf, \"undefined\");\nfunction isNull(subject) {\n  return subject === null;\n}\nfunction isHTMLElement(subject) {\n  try {\n    return subject instanceof (subject.ownerDocument.defaultView || window).HTMLElement;\n  } catch (e) {\n    return false;\n  }\n}\nfunction toArray(value) {\n  return isArray(value) ? value : [value];\n}\nfunction forEach(values, iteratee) {\n  toArray(values).forEach(iteratee);\n}\nfunction push(array, items) {\n  array.push(...toArray(items));\n  return array;\n}\nconst arrayProto = Array.prototype;\nfunction slice(arrayLike, start, end) {\n  return arrayProto.slice.call(arrayLike, start, end);\n}\nfunction includes(arrayLike, value) {\n  return arrayProto.includes.call(arrayLike, value);\n}\nfunction find(arrayLike, predicate) {\n  return arrayProto.find.call(arrayLike, predicate);\n}\nfunction assert(assertion, message) {\n  if (!assertion) {\n    throw new Error(message);\n  }\n}\nconst error = console.error;\nfunction abstractMethod() {\n  assert(0, \"Abstract!\");\n}\nconst assign = Object.assign;\nconst ownKeys = Object.keys;\nfunction forOwn(object, iteratee, right) {\n  if (object) {\n    (right ? ownKeys(object).reverse() : ownKeys(object)).forEach((key) => {\n      key !== \"__proto__\" && iteratee(object[key], key);\n    });\n  }\n  return object;\n}\nfunction merge(object, ...sources) {\n  sources.forEach((source) => {\n    forOwn(source, (value, key) => {\n      if (isArray(value)) {\n        value = value.slice();\n      } else if (isObject(value)) {\n        value = merge({}, isObject(object[key]) ? object[key] : {}, value);\n      }\n      object[key] = value;\n    });\n  });\n  return object;\n}\nfunction omit(object, keys) {\n  forEach(keys || ownKeys(object), (key) => {\n    delete object[key];\n  });\n  return object;\n}\nfunction inherit(child2, parent) {\n  return assign(Object.create(parent), child2);\n}\nfunction parseOption(option, defaults) {\n  return option === false || option === null ? false : merge({}, defaults || {}, isObject(option) ? option : {});\n}\nfunction toggleClass(elm, classes, force) {\n  if (elm) {\n    forEach(isString(classes) ? classes.split(\" \") : classes, (className) => {\n      className && elm.classList.toggle(className, force);\n    });\n  }\n}\nfunction addClass(elm, classes) {\n  toggleClass(elm, classes, true);\n}\nfunction append(parent, ...children2) {\n  parent && parent.append(...children2);\n}\nfunction before(ref, ...nodes) {\n  ref && ref.before(...nodes);\n}\nfunction matches(elm, selector) {\n  return isHTMLElement(elm) && elm.matches(selector);\n}\nfunction children(parent, selector) {\n  const children2 = parent ? slice(parent.children) : [];\n  return selector ? children2.filter((child2) => matches(child2, selector)) : children2;\n}\nfunction child(parent, selector) {\n  return selector ? children(parent, selector)[0] : parent.firstElementChild;\n}\nfunction closest(from, selector) {\n  return from.closest(selector);\n}\nfunction removeAttribute(elms, attrs) {\n  forEach(elms, (elm) => {\n    forEach(attrs, (attr) => {\n      elm && elm.removeAttribute(attr);\n    });\n  });\n}\nfunction setAttribute(elms, attrs, value) {\n  if (isObject(attrs)) {\n    forOwn(attrs, (value2, name) => {\n      setAttribute(elms, name, value2);\n    });\n  } else {\n    forEach(elms, (elm) => {\n      isNull(value) || value === \"\" ? removeAttribute(elm, attrs) : elm.setAttribute(attrs, String(value));\n    });\n  }\n}\nfunction create(tag2, attrs, parent) {\n  const elm = document.createElement(tag2);\n  if (attrs) {\n    isString(attrs) ? addClass(elm, attrs) : setAttribute(elm, attrs);\n  }\n  parent && append(parent, elm);\n  return elm;\n}\nfunction style(elm, prop, value) {\n  if (isUndefined(value)) {\n    return getComputedStyle(elm)[prop];\n  }\n  if (!isNull(value)) {\n    elm.style[prop] = `${value}`;\n  }\n}\nfunction display(elm, display2) {\n  style(elm, \"display\", display2);\n}\nfunction focus(elm) {\n  isHTMLElement(elm) && elm.focus({ preventScroll: true });\n}\nfunction getAttribute(elm, attr) {\n  return elm.getAttribute(attr);\n}\nfunction hasClass(elm, className) {\n  return !!elm && elm.classList.contains(className);\n}\nfunction rect(target) {\n  return target.getBoundingClientRect();\n}\nfunction removeNode(nodes) {\n  forEach(nodes, (node) => {\n    if (node && node.parentNode) {\n      node.parentNode.removeChild(node);\n    }\n  });\n}\nfunction measure(parent, value) {\n  if (isString(value)) {\n    const div2 = create(\"div\", { style: `width: ${value}; position: absolute;` }, parent);\n    value = rect(div2).width;\n    removeNode(div2);\n  }\n  return value;\n}\nfunction parseHtml(html) {\n  return child(new DOMParser().parseFromString(html, \"text/html\").body);\n}\nfunction prevent(e, stopPropagation) {\n  e.preventDefault();\n  if (stopPropagation) {\n    e.stopPropagation();\n    e.stopImmediatePropagation();\n  }\n}\nfunction query(parent, selector) {\n  return parent && parent.querySelector(selector);\n}\nfunction queryAll(parent, selector) {\n  return selector && parent ? slice(parent.querySelectorAll(selector)) : [];\n}\nfunction removeClass(elm, classes) {\n  toggleClass(elm, classes, false);\n}\nfunction timeOf(e) {\n  return e.timeStamp;\n}\nfunction unit(value) {\n  return isString(value) ? value : value ? `${value}px` : \"\";\n}\nfunction buildAttrs(attrs) {\n  let result = \"\";\n  forOwn(attrs, (value, key) => {\n    result += value || value === 0 ? ` ${key}${value !== true ? `=\"${value}\"` : \"\"}` : \"\";\n  });\n  return result.trim();\n}\nfunction classNames(...args) {\n  return args.reduce((classes, value) => {\n    return `${classes} ${isArray(value) ? classNames(...value) : value || \"\"}`.trim();\n  }, \"\");\n}\nfunction tag(tag2, attrs) {\n  attrs = isArray(attrs) || !isObject(attrs) ? { class: classNames(attrs) } : attrs;\n  return `<${`${tag2} ${attrs ? buildAttrs(attrs) : \"\"}`.trim()}>`;\n}\nfunction div(attrs) {\n  return tag(\"div\", attrs);\n}\nconst { min, max, floor, ceil, abs, sign } = Math;\nfunction approximatelyEqual(x, y, epsilon) {\n  return abs(x - y) < epsilon;\n}\nfunction between(number, x, y, exclusive) {\n  const minimum = min(x, y);\n  const maximum = max(x, y);\n  return exclusive ? minimum < number && number < maximum : minimum <= number && number <= maximum;\n}\nfunction clamp(number, x, y) {\n  const minimum = min(x, y);\n  const maximum = max(x, y);\n  return min(max(minimum, number), maximum);\n}\nfunction camelToKebab(string) {\n  return string.replace(/([a-z0-9])([A-Z])/g, \"$1-$2\").toLowerCase();\n}\nfunction format(string, ...replacements) {\n  return replacements.reduce((prev, curr) => prev.replace(\"%s\", `${curr}`), string);\n}\nfunction pad(number, length = 2) {\n  return `${number}`.padStart(length, \"0\");\n}\nconst ids = {};\nfunction uniqueId(prefix) {\n  return `${prefix}${pad(ids[prefix] = (ids[prefix] || 0) + 1)}`;\n}\nfunction forEachEvent(events, iteratee) {\n  forEach(events, (event) => {\n    isString(event) && event.split(\" \").forEach(iteratee);\n  });\n}\nfunction EventBinder(removersRef) {\n  const removers = removersRef || /* @__PURE__ */ new Set();\n  const key = removersRef ? {} : void 0;\n  let destroyed;\n  function bind(target, events, callback, options) {\n    assert(!destroyed);\n    forEachEvent(events, (event) => {\n      target.addEventListener(event, callback, options);\n      removers.add([target.removeEventListener.bind(target, event, callback, options), key]);\n    });\n  }\n  function destroy(hard) {\n    removers.forEach((remover) => {\n      if (!key || remover[1] === key) {\n        remover[0]();\n        removers.delete(remover);\n      }\n    });\n    destroyed = hard;\n  }\n  return {\n    bind,\n    lock: apply(EventBinder, removers),\n    destroy\n  };\n}\nfunction EventBus(listenersRef) {\n  const listeners = listenersRef || {};\n  const key = listenersRef ? {} : void 0;\n  let destroyed;\n  function on(events, callback) {\n    assert(!destroyed);\n    forEachEvent(events, (event) => {\n      listeners[event] = push(get(event), [[callback, key]]);\n    });\n  }\n  function off(events, callback) {\n    forEachEvent(events, (event) => {\n      listeners[event] = get(event).filter((listener) => !((!callback || listener[0] === callback) && listener[1] === key));\n    });\n  }\n  function emit(event, ...args) {\n    get(event).forEach((listener) => listener[0] && listener[0](...args));\n  }\n  function get(event) {\n    return listeners[event] || [];\n  }\n  function destroy(hard) {\n    forOwn(listeners, (entries, event) => {\n      listeners[event] = entries.filter((listener) => {\n        const unlocked = !key || listener[1] === key;\n        unlocked && empty(listener);\n        return !unlocked;\n      });\n    });\n    !key && omit(listeners);\n    destroyed = hard;\n  }\n  return {\n    on,\n    off,\n    emit,\n    lock: apply(EventBus, listeners),\n    destroy\n  };\n}\nfunction EventInterface(binder = EventBinder(), bus = EventBus()) {\n  function lock() {\n    return EventInterface(binder.lock(), bus.lock());\n  }\n  function destroy(hard) {\n    binder.destroy(hard);\n    bus.destroy(hard);\n  }\n  return assign({}, binder, bus, { lock, destroy });\n}\nfunction RequestInterval(interval, onInterval, onUpdate, limit) {\n  const { now } = Date;\n  let startTime;\n  let rate = 0;\n  let id;\n  let paused = true;\n  let count = 0;\n  function update() {\n    if (!paused) {\n      rate = interval ? min((now() - startTime) / interval, 1) : 1;\n      onUpdate && onUpdate(rate);\n      if (rate >= 1) {\n        onInterval();\n        startTime = now();\n        if (limit && ++count >= limit) {\n          return pause();\n        }\n      }\n      id = raf(update);\n    }\n  }\n  function start(resume) {\n    resume || cancel();\n    startTime = now() - (resume ? rate * interval : 0);\n    paused = false;\n    id = raf(update);\n  }\n  function pause() {\n    paused = true;\n  }\n  function rewind() {\n    startTime = now();\n    rate = 0;\n    if (onUpdate) {\n      onUpdate(rate);\n    }\n  }\n  function cancel() {\n    id && cancelAnimationFrame(id);\n    rate = 0;\n    id = 0;\n    paused = true;\n  }\n  function set(time) {\n    interval = time;\n  }\n  function isPaused() {\n    return paused;\n  }\n  return {\n    start,\n    rewind,\n    pause,\n    cancel,\n    set,\n    isPaused\n  };\n}\nfunction State(initialState) {\n  let state = initialState;\n  function set(value) {\n    state = value;\n  }\n  function is(states) {\n    return includes(toArray(states), state);\n  }\n  return { set, is };\n}\nfunction Throttle(func, duration) {\n  const interval = RequestInterval(duration || 0, func, void 0, 1);\n  return () => {\n    interval.isPaused() && interval.start();\n  };\n}\nexport {\n  EventBinder,\n  EventBus,\n  EventInterface,\n  RequestInterval,\n  State,\n  Throttle,\n  abs,\n  abstractMethod,\n  addClass,\n  append,\n  apply,\n  approximatelyEqual,\n  assert,\n  assign,\n  before,\n  between,\n  buildAttrs,\n  camelToKebab,\n  ceil,\n  child,\n  children,\n  clamp,\n  classNames,\n  closest,\n  create,\n  display,\n  div,\n  empty,\n  error,\n  find,\n  floor,\n  focus,\n  forEach,\n  forOwn,\n  format,\n  getAttribute,\n  hasClass,\n  includes,\n  inherit,\n  isArray,\n  isBoolean,\n  isFunction,\n  isHTMLElement,\n  isNull,\n  isObject,\n  isString,\n  isUndefined,\n  matches,\n  max,\n  measure,\n  merge,\n  min,\n  nextTick,\n  noop,\n  omit,\n  ownKeys,\n  pad,\n  parseHtml,\n  parseOption,\n  prevent,\n  push,\n  query,\n  queryAll,\n  raf,\n  rect,\n  removeAttribute,\n  removeClass,\n  removeNode,\n  setAttribute,\n  sign,\n  slice,\n  style,\n  tag,\n  timeOf,\n  toArray,\n  toggleClass,\n  uniqueId,\n  unit\n};\n","import { ARROW_DOWN, ARROW_LEFT, ARROW_RIGHT, ARROW_UP } from '../../constants/arrows';\r\nimport { RTL, TTB } from '../../constants/directions';\r\nimport { Splide } from '../../core/Splide/Splide';\r\nimport { BaseComponent, ComponentConstructor, Components, Options } from '../../types';\r\nimport { apply } from '../../../../../utils';\r\n\r\n\r\n/**\r\n * The interface for the Direction component.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport interface DirectionComponent extends BaseComponent {\r\n  resolve<K extends keyof typeof ORIENTATION_MAP>(prop: K, axisOnly?: boolean, direction?: Options['direction']): typeof ORIENTATION_MAP[ K ][ number ] | K;\r\n  resolve<R extends string>(prop: R, axisOnly?: boolean, direction?: Options['direction']): R;\r\n\r\n  orient(value: number): number;\r\n  left(): string;\r\n  right(): string;\r\n  width(): string;\r\n}\r\n\r\n/**\r\n * The translation map for directions.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport const ORIENTATION_MAP = {\r\n  width: ['height'],\r\n  left: ['top', 'right'],\r\n  right: ['bottom', 'left'],\r\n  x: ['y'],\r\n  X: ['Y'],\r\n  Y: ['X'],\r\n  ArrowLeft: [ARROW_UP, ARROW_RIGHT],\r\n  ArrowRight: [ARROW_DOWN, ARROW_LEFT],\r\n} as const;\r\n\r\n/**\r\n * The component that absorbs the difference among directions.\r\n *\r\n * @since 3.0.0\r\n *\r\n * @param Splide     - A Splide instance.\r\n * @param Components - A collection of components.\r\n * @param options    - Options.\r\n *\r\n * @return A Direction component object.\r\n */\r\nexport const Direction: ComponentConstructor<DirectionComponent> = (Splide: Splide, Components: Components, options: Options) => {\r\n  /**\r\n   * Resolves the provided property name.\r\n   *\r\n   * @param prop      - A property name to translate.\r\n   * @param axisOnly  - Optional. If `ture`, returns the same property for LTR and RTL.\r\n   * @param direction - Optional. Specify the direction. The default value is the `direction` option.\r\n   */\r\n  function resolve(\r\n    prop: string,\r\n    axisOnly?: boolean,\r\n    direction: Options[ 'direction' ] = options.direction,\r\n  ): string {\r\n    const index = direction === RTL && !axisOnly ? 1 : direction === TTB ? 0 : -1;\r\n\r\n    return ORIENTATION_MAP[prop] && ORIENTATION_MAP[prop][index]\r\n      || prop.replace(/width|left|right/i, (match, offset) => {\r\n        const replacement = ORIENTATION_MAP[match.toLowerCase()][index] || match;\r\n        return offset > 0 ? replacement.charAt(0).toUpperCase() + replacement.slice(1) : replacement;\r\n      });\r\n  }\r\n\r\n  /**\r\n   * Orients the value towards the current direction.\r\n   *\r\n   * @param value     - A value to orient.\r\n   * @param direction - Optional. Specify the direction. The default value is the `direction` option.\r\n   *\r\n   * @return The oriented value.\r\n   */\r\n  function orient(value: number, direction: Options[ 'direction' ] = options.direction): number {\r\n    return value * (direction === RTL ? 1 : -1);\r\n  }\r\n\r\n  return {\r\n    resolve,\r\n    orient,\r\n    left: apply(resolve, 'left'),\r\n    right: apply(resolve, 'right'),\r\n    width: apply(resolve, 'width'),\r\n  };\r\n};\r\n","const ARROW = 'Arrow';\r\nexport const ARROW_LEFT = `${ ARROW }Left`;\r\nexport const ARROW_RIGHT = `${ ARROW }Right`;\r\nexport const ARROW_UP = `${ ARROW }Up`;\r\nexport const ARROW_DOWN = `${ ARROW }Down`;","/**\r\n * Enumerates slides from left to right.\r\n */\r\nexport const LTR = 'ltr';\r\n\r\n/**\r\n * Enumerates slides from right to left.\r\n */\r\nexport const RTL = 'rtl';\r\n\r\n/**\r\n * Enumerates slides in a col.\r\n */\r\nexport const TTB = 'ttb';\r\n","/**\r\n * The project code.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport const PROJECT_CODE = 'splide';\r\n\r\n/**\r\n * The data attribute prefix.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport const DATA_ATTRIBUTE = `data-${ PROJECT_CODE }`;\r\n","import { PROJECT_CODE } from './project';\r\n\r\n\r\n/**\r\n * The prefix for classes.\r\n *\r\n * @since 4.1.0\r\n */\r\nexport const CLASS_PREFIX = `${ PROJECT_CODE }__`;\r\n\r\n/**\r\n * The prefix for status classes.\r\n *\r\n * @since 4.1.0\r\n */\r\nexport const STATUS_CLASS_PREFIX = 'is-';\r\n\r\n/**\r\n * All classes as constants.\r\n */\r\nexport const CLASS_ROOT = PROJECT_CODE;\r\nexport const CLASS_TRACK = `${ CLASS_PREFIX }track`;\r\nexport const CLASS_LIST = `${ CLASS_PREFIX }list`;\r\nexport const CLASS_SLIDE = `${ CLASS_PREFIX }slide`;\r\nexport const CLASS_CLONE = `${ CLASS_SLIDE }--clone`;\r\nexport const CLASS_CONTAINER = `${ CLASS_SLIDE }__container`;\r\nexport const CLASS_ARROWS = `${ CLASS_PREFIX }arrows`;\r\nexport const CLASS_ARROW = `${ CLASS_PREFIX }arrow`;\r\nexport const CLASS_ARROW_PREV = `${ CLASS_ARROW }--prev`;\r\nexport const CLASS_ARROW_NEXT = `${ CLASS_ARROW }--next`;\r\nexport const CLASS_PAGINATION = `${ CLASS_PREFIX }pagination`;\r\nexport const CLASS_PAGINATION_PAGE = `${ CLASS_PAGINATION }__page`;\r\nexport const CLASS_PROGRESS = `${ CLASS_PREFIX }progress`;\r\nexport const CLASS_PROGRESS_BAR = `${ CLASS_PROGRESS }__bar`;\r\nexport const CLASS_TOGGLE = `${ CLASS_PREFIX }toggle`;\r\nexport const CLASS_TOGGLE_PLAY = `${ CLASS_TOGGLE }__play`;\r\nexport const CLASS_TOGGLE_PAUSE = `${ CLASS_TOGGLE }__pause`;\r\nexport const CLASS_SPINNER = `${ CLASS_PREFIX }spinner`;\r\nexport const CLASS_SR = `${ CLASS_PREFIX }sr`;\r\nexport const CLASS_INITIALIZED = `${ STATUS_CLASS_PREFIX }initialized`;\r\nexport const CLASS_ACTIVE = `${ STATUS_CLASS_PREFIX }active`;\r\nexport const CLASS_PREV = `${ STATUS_CLASS_PREFIX }prev`;\r\nexport const CLASS_NEXT = `${ STATUS_CLASS_PREFIX }next`;\r\nexport const CLASS_VISIBLE = `${ STATUS_CLASS_PREFIX }visible`;\r\nexport const CLASS_LOADING = `${ STATUS_CLASS_PREFIX }loading`;\r\nexport const CLASS_FOCUS_IN = `${ STATUS_CLASS_PREFIX }focus-in`;\r\nexport const CLASS_OVERFLOW = `${ STATUS_CLASS_PREFIX }overflow`;\r\n\r\n/**\r\n * The array with all status classes except for `is-initialized`.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport const STATUS_CLASSES = [\r\n  CLASS_ACTIVE,\r\n  CLASS_VISIBLE,\r\n  CLASS_PREV,\r\n  CLASS_NEXT,\r\n  CLASS_LOADING,\r\n  CLASS_FOCUS_IN,\r\n  CLASS_OVERFLOW,\r\n];\r\n\r\n/**\r\n * The collection of classes for elements that Splide dynamically creates.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport const CLASSES = {\r\n  slide: CLASS_SLIDE,\r\n  clone: CLASS_CLONE,\r\n  arrows: CLASS_ARROWS,\r\n  arrow: CLASS_ARROW,\r\n  prev: CLASS_ARROW_PREV,\r\n  next: CLASS_ARROW_NEXT,\r\n  pagination: CLASS_PAGINATION,\r\n  page: CLASS_PAGINATION_PAGE,\r\n  spinner: CLASS_SPINNER,\r\n};\r\n","import { Options } from '../types';\r\nimport { CLASSES } from './classes';\r\nimport { I18N } from './i18n';\r\n\r\n\r\n/**\r\n * The collection of default options.\r\n * Note that this collection does not contain all options.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport const DEFAULTS: Options = {\r\n  type: 'slide',\r\n  speed: 400,\r\n  perPage: 1,\r\n  easing: 'cubic-bezier(0.25, 1, 0.5, 1)',\r\n  drag: true,\r\n  direction: 'ltr',\r\n  interval: 5000,\r\n  trimSpace: true,\r\n  focusableNodes: 'a, button, textarea, input, select, iframe',\r\n  classes: CLASSES,\r\n  i18n: I18N,\r\n  reducedMotion: {\r\n    speed: 0,\r\n    rewindSpeed: 0,\r\n    autoplay: 'pause',\r\n  },\r\n};","/**\r\n * The collection of i18n strings.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport const I18N = {\r\n  prev: 'Previous slide',\r\n  next: 'Next slide',\r\n  first: 'Go to first slide',\r\n  last: 'Go to last slide',\r\n  slideX: 'Go to slide %s',\r\n  pageX: 'Go to page %s',\r\n  play: 'Start autoplay',\r\n  pause: 'Pause autoplay',\r\n  carousel: 'carousel',\r\n  slide: 'slide',\r\n  select: 'Select a slide to show',\r\n  slideLabel: '%s of %s', // [ slide number ] / [ slide size ]\r\n};\r\n","import { RendererConfig } from '../types/types';\r\n\r\n\r\n/**\r\n * Default options for generating static HTML.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport const RENDERER_DEFAULT_CONFIG: RendererConfig = {\r\n  listTag: 'ul',\r\n  slideTag: 'li',\r\n};\r\n","import { Options } from '../../types';\r\nimport { forOwn } from '@splidejs/utils';\r\n\r\n\r\ninterface Styles {\r\n  [breakpoint: string]: {\r\n    [selector: string]: Record<string, string | number>\r\n  };\r\n}\r\n\r\n/**\r\n * The class for generating styles as a string.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport class Style {\r\n  /**\r\n   * The collection of registered styles categorized by each breakpoint.\r\n   */\r\n  private readonly styles: Styles = {};\r\n\r\n  /**\r\n   * The ID of the slider.\r\n   */\r\n  private readonly id: string;\r\n\r\n  /**\r\n   * Holds options.\r\n   */\r\n  private readonly options: Options;\r\n\r\n  /**\r\n   * The Style constructor.\r\n   *\r\n   * @param id      - A slider ID.\r\n   * @param options - Options.\r\n   */\r\n  constructor(id: string, options: Options) {\r\n    this.id = id;\r\n    this.options = options;\r\n  }\r\n\r\n  /**\r\n   * Registers a CSS rule.\r\n   *\r\n   * @param selector - A selector.\r\n   * @param prop\r\n   * @param value\r\n   * @param breakpoint\r\n   */\r\n  rule(selector: string, prop: string, value: string | number, breakpoint?: string): void {\r\n    breakpoint = breakpoint || 'default';\r\n    const selectors = (this.styles[breakpoint] = this.styles[breakpoint] || {});\r\n    const styles = (selectors[selector] = selectors[selector] || {});\r\n    styles[prop] = value;\r\n  }\r\n\r\n  /**\r\n   * Builds styles as a single string.\r\n   *\r\n   * @return Built styles.\r\n   */\r\n  build(): string {\r\n    let css = '';\r\n\r\n    if (this.styles.default) {\r\n      css += this.buildSelectors(this.styles.default);\r\n    }\r\n\r\n    Object.keys(this.styles)\r\n      .sort((n, m) => this.options.mediaQuery === 'min' ? +n - +m : +m - +n)\r\n      .forEach(breakpoint => {\r\n        if (breakpoint !== 'default') {\r\n          css += `@media screen and (max-width: ${ breakpoint }px) {`;\r\n          css += this.buildSelectors(this.styles[breakpoint]);\r\n          css += `}`;\r\n        }\r\n      });\r\n\r\n    return css;\r\n  }\r\n\r\n  /**\r\n   * Builds styles for each breakpoint.\r\n   *\r\n   * @param selectors - An object with styles.\r\n   *\r\n   * @return Built styles.\r\n   */\r\n  private buildSelectors(selectors: Record<string, Record<string, string | number>>): string {\r\n    let css = '';\r\n\r\n    forOwn(selectors, (styles, selector) => {\r\n      css += `${ `#${ this.id } ${ selector }`.trim() } {`;\r\n\r\n      forOwn(styles, (value, prop) => {\r\n        if (value || value === 0) {\r\n          css += `${ prop }: ${ value };`;\r\n        }\r\n      });\r\n\r\n      css += '}';\r\n    });\r\n\r\n    return css;\r\n  }\r\n}\r\n","import { PROJECT_CODE } from '../../../constants/project';\r\n\r\n\r\n/**\r\n * Throws an error if the provided condition is falsy.\r\n *\r\n * @param condition - If falsy, an error is thrown.\r\n * @param message   - Optional. A message to display.\r\n */\r\nexport function assert(condition: any, message?: string): void {\r\n  if (!condition) {\r\n    throw new Error(`[${ PROJECT_CODE }] ${ message || '' }`);\r\n  }\r\n}\r\n","import { PATH, SIZE, XML_NAME_SPACE } from '../../components/Arrows/path';\r\nimport { Direction, DirectionComponent } from '../../components/Direction/Direction';\r\nimport { CLASS_ACTIVE, CLASS_CLONE, CLASS_LIST, CLASS_ROOT, CLASS_SLIDE, CLASS_TRACK } from '../../constants/classes';\r\nimport { DEFAULTS } from '../../constants/defaults';\r\nimport { TTB } from '../../constants/directions';\r\nimport { EVENT_MOUNTED } from '../../constants/events';\r\nimport { LOOP, SLIDE } from '../../constants/types';\r\nimport { Splide } from '../../core/Splide/Splide';\r\nimport { Options } from '../../types';\r\nimport {\r\n  assign,\r\n  camelToKebab,\r\n  child,\r\n  forOwn,\r\n  isObject,\r\n  isString,\r\n  max,\r\n  merge,\r\n  push,\r\n  queryAll,\r\n  removeNode,\r\n  uniqueId,\r\n  unit,\r\n} from '@splidejs/utils';\r\nimport { CLASS_RENDERED } from '../constants/classes';\r\nimport { RENDERER_DEFAULT_CONFIG } from '../constants/defaults';\r\nimport { Style } from '../Style/Style';\r\nimport { RendererConfig, SlideContent } from '../types/types';\r\nimport { assert } from '../../utils';\r\n\r\n\r\n/**\r\n * The class to generate static HTML of the slider for the first view.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport class SplideRenderer {\r\n  /**\r\n   * Removes a style element and clones.\r\n   *\r\n   * @param splide - A Splide instance.\r\n   */\r\n  static clean(splide: Splide): void {\r\n    const { on } = splide.event;\r\n    const { root } = splide;\r\n    const clones = queryAll(root, `.${ CLASS_CLONE }`);\r\n\r\n    on(EVENT_MOUNTED, () => {\r\n      removeNode(child(root, 'style'));\r\n    });\r\n\r\n    removeNode(clones);\r\n  }\r\n\r\n  /**\r\n   * Holds slide contents.\r\n   */\r\n  private readonly contents: string[] | SlideContent[];\r\n\r\n  /**\r\n   * Stores data of slides.\r\n   */\r\n  private readonly slides: SlideContent[] = [];\r\n\r\n  /**\r\n   * The Direction component.\r\n   */\r\n  private readonly Direction: DirectionComponent;\r\n\r\n  /**\r\n   * Holds the Style instance.\r\n   */\r\n  private readonly Style: Style;\r\n\r\n  /**\r\n   * Holds options.\r\n   */\r\n  private readonly options: Options = {};\r\n\r\n  /**\r\n   * Holds options for this instance.\r\n   */\r\n  private readonly config: RendererConfig;\r\n\r\n  /**\r\n   * The slider ID.\r\n   */\r\n  private readonly id: string;\r\n\r\n  /**\r\n   * An array with options for each breakpoint.\r\n   */\r\n  private readonly breakpoints: [string, Options][] = [];\r\n\r\n  /**\r\n   * The SplideRenderer constructor.\r\n   *\r\n   * @param contents - An array with slide contents. Each item must be an HTML or a plain text.\r\n   * @param options  - Optional. Slider options.\r\n   * @param config   - Static default options.\r\n   * @param defaults - Default options for the slider. Pass `Splide.defaults` if you are using it.\r\n   */\r\n  constructor(contents: string[] | SlideContent[], options?: Options, config?: RendererConfig, defaults?: Options) {\r\n    merge(DEFAULTS, defaults || {});\r\n    merge(merge(this.options, DEFAULTS), options || {});\r\n\r\n    this.contents = contents;\r\n    this.config = assign({}, RENDERER_DEFAULT_CONFIG, config || {});\r\n    this.id = this.config.id || uniqueId('splide');\r\n    this.Style = new Style(this.id, this.options);\r\n    this.Direction = Direction(null, null, this.options, undefined);\r\n\r\n    assert(this.contents.length, 'Provide at least 1 content.');\r\n\r\n    this.init();\r\n  }\r\n\r\n  /**\r\n   * Initializes the instance.\r\n   */\r\n  private init(): void {\r\n    this.parseBreakpoints();\r\n    this.initSlides();\r\n    this.registerRootStyles();\r\n    this.registerTrackStyles();\r\n    this.registerSlideStyles();\r\n    this.registerListStyles();\r\n  }\r\n\r\n  /**\r\n   * Initializes slides.\r\n   */\r\n  private initSlides(): void {\r\n    push(this.slides, this.contents.map((content, index) => {\r\n      content = isString(content) ? { html: content } : content;\r\n      content.styles = content.styles || {};\r\n      content.attrs = content.attrs || {};\r\n\r\n      this.cover(content);\r\n\r\n      const classes = `${ this.options.classes.slide } ${ index === 0 ? CLASS_ACTIVE : '' }`;\r\n\r\n      assign(content.attrs, {\r\n        class: `${ classes } ${ content.attrs.class || '' }`.trim(),\r\n        style: this.buildStyles(content.styles),\r\n      });\r\n\r\n      return content;\r\n    }));\r\n\r\n    if (this.isLoop()) {\r\n      this.generateClones(this.slides);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Registers styles for the root element.\r\n   */\r\n  private registerRootStyles(): void {\r\n    this.breakpoints.forEach(([width, options]) => {\r\n      this.Style.rule(' ', 'max-width', unit(options.width), width);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Registers styles for the track element.\r\n   */\r\n  private registerTrackStyles(): void {\r\n    const { Style } = this;\r\n    const selector = `.${ CLASS_TRACK }`;\r\n\r\n    this.breakpoints.forEach(([width, options]) => {\r\n      Style.rule(selector, this.resolve('paddingLeft'), this.cssPadding(options, false), width);\r\n      Style.rule(selector, this.resolve('paddingRight'), this.cssPadding(options, true), width);\r\n      Style.rule(selector, 'height', this.cssTrackHeight(options), width);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Registers styles for the list element.\r\n   */\r\n  private registerListStyles(): void {\r\n    const { Style } = this;\r\n    const selector = `.${ CLASS_LIST }`;\r\n\r\n    this.breakpoints.forEach(([width, options]) => {\r\n      Style.rule(selector, 'transform', this.buildTranslate(options), width);\r\n\r\n      if (!this.cssSlideHeight(options)) {\r\n        Style.rule(selector, 'aspect-ratio', this.cssAspectRatio(options), width);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Registers styles for slides and clones.\r\n   */\r\n  private registerSlideStyles(): void {\r\n    const { Style } = this;\r\n    const selector = `.${ CLASS_SLIDE }`;\r\n\r\n    this.breakpoints.forEach(([width, options]) => {\r\n      Style.rule(selector, 'width', this.cssSlideWidth(options), width);\r\n      Style.rule(selector, 'height', this.cssSlideHeight(options) || '100%', width);\r\n      Style.rule(selector, this.resolve('marginRight'), unit(options.gap) || '0px', width);\r\n      Style.rule(`${ selector } > img`, 'display', options.cover ? 'none' : 'inline', width);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Builds multiple `translateX` for the list element.\r\n   *\r\n   * @param options - Options for each breakpoint.\r\n   *\r\n   * @return A string with multiple translate functions.\r\n   */\r\n  private buildTranslate(options: Options): string {\r\n    const { resolve, orient } = this.Direction;\r\n    const values = [];\r\n\r\n    values.push(this.cssOffsetClones(options));\r\n    values.push(this.cssOffsetGaps(options));\r\n\r\n    if (this.isCenter(options)) {\r\n      values.push(this.buildCssValue(orient(-50), '%'));\r\n      values.push(...this.cssOffsetCenter(options));\r\n    }\r\n\r\n    return values\r\n      .filter(Boolean)\r\n      .map(value => `translate${ resolve('X') }(${ value })`)\r\n      .join(' ');\r\n  }\r\n\r\n  /**\r\n   * Returns offset for the list element.\r\n   * This does not include gaps because it can not be converted into percent.\r\n   *\r\n   * @param options - Options for each breakpoint.\r\n   *\r\n   * @return The offset.\r\n   */\r\n  private cssOffsetClones(options: Options): string {\r\n    const { resolve, orient } = this.Direction;\r\n    const cloneCount = this.getCloneCount();\r\n\r\n    if (this.isFixedWidth(options)) {\r\n      const { value, unit } = this.parseCssValue(options[resolve('fixedWidth')]);\r\n      return this.buildCssValue(orient(value) * cloneCount, unit);\r\n    }\r\n\r\n    const percent = 100 * cloneCount / options.perPage;\r\n    return `${ orient(percent) }%`;\r\n  }\r\n\r\n  /**\r\n   * Returns offset for centering the active slide.\r\n   *\r\n   * Note:\r\n   * ( 100% + gap ) / perPage - gap\r\n   * 100% / perPage + gap / perPage - gap;\r\n   * 50% / perPage + ( gap / perPage - gap ) / 2;\r\n   *\r\n   * @param options - Options for each breakpoint.\r\n   *\r\n   * @return The offset.\r\n   */\r\n  private cssOffsetCenter(options: Options): string[] {\r\n    const { resolve, orient } = this.Direction;\r\n\r\n    if (this.isFixedWidth(options)) {\r\n      const { value, unit } = this.parseCssValue(options[resolve('fixedWidth')]);\r\n      return [this.buildCssValue(orient(value / 2), unit)];\r\n    }\r\n\r\n    const values = [];\r\n    const { perPage, gap } = options;\r\n\r\n    values.push(`${ orient(50 / perPage) }%`);\r\n\r\n    if (gap) {\r\n      const { value, unit } = this.parseCssValue(gap);\r\n      const gapOffset = (value / perPage - value) / 2;\r\n      values.push(this.buildCssValue(orient(gapOffset), unit));\r\n    }\r\n\r\n    return values;\r\n  }\r\n\r\n  /**\r\n   * Returns offset for gaps.\r\n   *\r\n   * @param options - Options for each breakpoint.\r\n   *\r\n   * @return The offset as `calc()`.\r\n   */\r\n  private cssOffsetGaps(options: Options): string {\r\n    const cloneCount = this.getCloneCount();\r\n\r\n    if (cloneCount && options.gap) {\r\n      const { orient } = this.Direction;\r\n      const { value, unit } = this.parseCssValue(options.gap);\r\n\r\n      if (this.isFixedWidth(options)) {\r\n        return this.buildCssValue(orient(value * cloneCount), unit);\r\n      }\r\n\r\n      const { perPage } = options;\r\n      const gaps = cloneCount / perPage;\r\n      return this.buildCssValue(orient(gaps * value), unit);\r\n    }\r\n\r\n    return '';\r\n  }\r\n\r\n  /**\r\n   * Resolves the prop for the current direction and converts it into the Kebab case.\r\n   *\r\n   * @param prop - A property name to resolve.\r\n   *\r\n   * @return A resolved property name in the Kebab case.\r\n   */\r\n  private resolve(prop: string): string {\r\n    return camelToKebab(this.Direction.resolve(prop));\r\n  }\r\n\r\n  /**\r\n   * Returns padding in the CSS format.\r\n   *\r\n   * @param options - Options.\r\n   * @param right   - Determines whether to get padding right or left.\r\n   *\r\n   * @return Padding in the CSS format.\r\n   */\r\n  private cssPadding(options: Options, right: boolean): string {\r\n    const { padding } = options;\r\n    const prop = this.Direction.resolve(right ? 'right' : 'left', true);\r\n    return padding && unit(padding[prop] || (isObject(padding) ? 0 : padding)) || '0px';\r\n  }\r\n\r\n  /**\r\n   * Returns height of the track element in the CSS format.\r\n   *\r\n   * @param options - Options.\r\n   *\r\n   * @return Height in the CSS format.\r\n   */\r\n  private cssTrackHeight(options: Options): string {\r\n    let height = '';\r\n\r\n    if (this.isVertical()) {\r\n      height = this.cssHeight(options);\r\n      assert(height, '\"height\" is missing.');\r\n      height = `calc(${ height } - ${ this.cssPadding(options, false) } - ${ this.cssPadding(options, true) })`;\r\n    }\r\n\r\n    return height;\r\n  }\r\n\r\n  /**\r\n   * Returns height provided though options in the CSS format.\r\n   *\r\n   * @param options - Options.\r\n   *\r\n   * @return Height in the CSS format.\r\n   */\r\n  private cssHeight(options: Options): string {\r\n    return unit(options.height);\r\n  }\r\n\r\n  /**\r\n   * Returns width of each slide in the CSS format.\r\n   *\r\n   * @param options - Options.\r\n   *\r\n   * @return Width in the CSS format.\r\n   */\r\n  private cssSlideWidth(options: Options): string {\r\n    return options.autoWidth\r\n      ? ''\r\n      : unit(options.fixedWidth) || (this.isVertical() ? '' : this.cssSlideSize(options));\r\n  }\r\n\r\n  /**\r\n   * Returns height of each slide in the CSS format.\r\n   *\r\n   * @param options - Options.\r\n   *\r\n   * @return Height in the CSS format.\r\n   */\r\n  private cssSlideHeight(options: Options): string {\r\n    return unit(options.fixedHeight)\r\n      || (this.isVertical()\r\n        ? (options.autoHeight ? '' : this.cssSlideSize(options))\r\n        : this.cssHeight(options)\r\n      );\r\n  }\r\n\r\n  /**\r\n   * Returns width or height of each slide in the CSS format, considering the current direction.\r\n   *\r\n   * @param options - Options.\r\n   *\r\n   * @return Width or height in the CSS format.\r\n   */\r\n  private cssSlideSize(options: Options): string {\r\n    const gap = unit(options.gap);\r\n    return `calc((100%${ gap && ` + ${ gap }` })/${ options.perPage || 1 }${ gap && ` - ${ gap }` })`;\r\n  }\r\n\r\n  /**\r\n   * Returns the aspectRatio value to simulate the `heightRatio` option.\r\n   *\r\n   * @param options - Options.\r\n   *\r\n   * @return aspectRatio in the CSS format.\r\n   */\r\n  private cssAspectRatio(options: Options): string {\r\n    const { heightRatio } = options;\r\n    return heightRatio ? `${ 1 / heightRatio }` : '';\r\n  }\r\n\r\n  /**\r\n   * Builds the css value by the provided value and unit.\r\n   *\r\n   * @param value - A value.\r\n   * @param unit  - A CSS unit.\r\n   *\r\n   * @return A built value for a CSS value.\r\n   */\r\n  private buildCssValue(value: number, unit: string): string {\r\n    return `${ value }${ unit }`;\r\n  }\r\n\r\n  /**\r\n   * Parses the CSS value into number and unit.\r\n   *\r\n   * @param value - A value to parse.\r\n   *\r\n   * @return An object with value and unit.\r\n   */\r\n  private parseCssValue(value: string | number): { value: number, unit: string } {\r\n    if (isString(value)) {\r\n      const number = parseFloat(value) || 0;\r\n      const unit = value.replace(/\\d*(\\.\\d*)?/, '') || 'px';\r\n      return { value: number, unit };\r\n    }\r\n\r\n    return { value, unit: 'px' };\r\n  }\r\n\r\n  /**\r\n   * Parses breakpoints and generate options for each breakpoint.\r\n   */\r\n  private parseBreakpoints(): void {\r\n    const { breakpoints } = this.options;\r\n\r\n    this.breakpoints.push(['default', this.options]);\r\n\r\n    if (breakpoints) {\r\n      forOwn(breakpoints, (options, width) => {\r\n        this.breakpoints.push([width, merge(merge({}, this.options), options)]);\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks if the slide width is fixed or not.\r\n   *\r\n   * @return `true` if the slide width is fixed, or otherwise `false`.\r\n   */\r\n  private isFixedWidth(options: Options): boolean {\r\n    return !!options[this.Direction.resolve('fixedWidth')];\r\n  }\r\n\r\n  /**\r\n   * Checks if the slider type is loop or not.\r\n   *\r\n   * @return `true` if the slider type is loop, or otherwise `false`.\r\n   */\r\n  private isLoop(): boolean {\r\n    return this.options.type === LOOP;\r\n  }\r\n\r\n  /**\r\n   * Checks if the active slide should be centered or not.\r\n   *\r\n   * @return `true` if the slide should be centered, or otherwise `false`.\r\n   */\r\n  private isCenter(options: Options): boolean {\r\n    if (options.focus === 'center') {\r\n      if (this.isLoop()) {\r\n        return true;\r\n      }\r\n\r\n      if (this.options.type === SLIDE) {\r\n        return !this.options.trimSpace;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Checks if the direction is TTB or not.\r\n   *\r\n   * @return `true` if the direction is TTB, or otherwise `false`.\r\n   */\r\n  private isVertical(): boolean {\r\n    return this.options.direction === TTB;\r\n  }\r\n\r\n  /**\r\n   * Builds classes of the root element.\r\n   *\r\n   * @return Classes for the root element as a single string.\r\n   */\r\n  private buildClasses(): string {\r\n    const { options } = this;\r\n\r\n    return [\r\n      CLASS_ROOT,\r\n      `${ CLASS_ROOT }--${ options.type }`,\r\n      `${ CLASS_ROOT }--${ options.direction }`,\r\n      options.drag && `${ CLASS_ROOT }--draggable`,\r\n      options.isNavigation && `${ CLASS_ROOT }--nav`,\r\n      CLASS_ACTIVE,\r\n      !this.config.hidden && CLASS_RENDERED,\r\n    ].filter(Boolean).join(' ');\r\n  }\r\n\r\n  /**\r\n   * Converts provided attributes into a single string.\r\n   *\r\n   * @param attrs - An object with attributes.\r\n   *\r\n   * @return A built string.\r\n   */\r\n  private buildAttrs(attrs: Record<string, string | number | boolean>): string {\r\n    let attr = '';\r\n\r\n    forOwn(attrs, (value, key) => {\r\n      attr += value ? ` ${ camelToKebab(key) }=\"${ value }\"` : '';\r\n    });\r\n\r\n    return attr.trim();\r\n  }\r\n\r\n  /**\r\n   * Converts provided styles into a single string.\r\n   *\r\n   * @param styles - An object with styles.\r\n   *\r\n   * @return A built string.\r\n   */\r\n  private buildStyles(styles: Record<string, string | number>): string {\r\n    let style = '';\r\n\r\n    forOwn(styles, (value, key) => {\r\n      style += ` ${ camelToKebab(key) }:${ value };`;\r\n    });\r\n\r\n    return style.trim();\r\n  }\r\n\r\n  /**\r\n   * Generates HTML of slides with inserting provided contents.\r\n   *\r\n   * @return The HTML for all slides and clones.\r\n   */\r\n  private renderSlides(): string {\r\n    const { slideTag: tag } = this.config;\r\n\r\n    return this.slides.map(content => {\r\n      return `<${ tag } ${ this.buildAttrs(content.attrs) }>${ content.html || '' }</${ tag }>`;\r\n    }).join('');\r\n  }\r\n\r\n  /**\r\n   * Add the `background` style for the cover mode.\r\n   *\r\n   * @param content - A slide content.\r\n   */\r\n  private cover(content: SlideContent): void {\r\n    const { styles, html = '' } = content;\r\n\r\n    if (this.options.cover && !this.options.lazyLoad) {\r\n      const src = html.match(/<img.*?src\\s*=\\s*(['\"])(.+?)\\1.*?>/);\r\n\r\n      if (src && src[2]) {\r\n        styles.background = `center/cover no-repeat url('${ src[2] }')`;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generates clones.\r\n   *\r\n   * @param contents - An array with SlideContent objects.\r\n   */\r\n  private generateClones(contents: SlideContent[]): void {\r\n    const { classes } = this.options;\r\n    const count = this.getCloneCount();\r\n    const slides = contents.slice();\r\n\r\n    while (slides.length < count) {\r\n      push(slides, slides);\r\n    }\r\n\r\n    push(slides.slice(-count).reverse(), slides.slice(0, count)).forEach((content, index) => {\r\n      const attrs = assign({}, content.attrs, { class: `${ content.attrs.class } ${ classes.clone }` });\r\n      const clone = assign({}, content, { attrs });\r\n      index < count ? contents.unshift(clone) : contents.push(clone);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Returns the number of clones to generate.\r\n   *\r\n   * @return A number of clones.\r\n   */\r\n  private getCloneCount(): number {\r\n    if (this.isLoop()) {\r\n      const { options } = this;\r\n\r\n      if (options.clones) {\r\n        return options.clones;\r\n      }\r\n\r\n      const perPage = max(...this.breakpoints.map(([, options]) => options.perPage));\r\n      return perPage * ((options.flickMaxPages || 1) + 1);\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Generates arrows and the wrapper element.\r\n   *\r\n   * @return The HTML for arrows.\r\n   */\r\n  private renderArrows(): string {\r\n    let html = '';\r\n\r\n    html += `<div class=\"${ this.options.classes.arrows }\">`;\r\n    html += this.renderArrow(true);\r\n    html += this.renderArrow(false);\r\n    html += `</div>`;\r\n\r\n    return html;\r\n  }\r\n\r\n  /**\r\n   * Generates an arrow HTML.\r\n   * Some attributes are temporary, and Splide changes them after mount.\r\n   *\r\n   * @param prev - Options for each breakpoint.\r\n   *\r\n   * @return The HTML for the prev or next arrow.\r\n   */\r\n  private renderArrow(prev: boolean): string {\r\n    const { classes, i18n } = this.options;\r\n    const attrs = {\r\n      class: `${ classes.arrow } ${ prev ? classes.prev : classes.next }`,\r\n      type: 'button',\r\n      ariaLabel: prev ? i18n.prev : i18n.next,\r\n    };\r\n\r\n    return `<button ${ this.buildAttrs(attrs) }>`\r\n      + `<svg xmlns=\"${ XML_NAME_SPACE }\" viewBox=\"0 0 ${ SIZE } ${ SIZE }\" width=\"${ SIZE }\" height=\"${ SIZE }\">`\r\n      + `<path d=\"${ this.options.arrowPath || PATH }\" />`\r\n      + `</svg>`\r\n      + `</button>`;\r\n  }\r\n\r\n  /**\r\n   * Returns the HTML of the slider.\r\n   *\r\n   * @return The generated HTML.\r\n   */\r\n  html(): string {\r\n    const { rootClass, listTag, arrows, beforeTrack, afterTrack, slider, beforeSlider, afterSlider } = this.config;\r\n\r\n    let html = '';\r\n\r\n    html += `<div id=\"${ this.id }\" class=\"${ this.buildClasses() } ${ rootClass || '' }\">`;\r\n    html += `<style>${ this.Style.build() }</style>`;\r\n\r\n    if (slider) {\r\n      html += beforeSlider || '';\r\n      html += `<div class=\"splide__slider\">`;\r\n    }\r\n\r\n    html += beforeTrack || '';\r\n\r\n    if (arrows) {\r\n      html += this.renderArrows();\r\n    }\r\n\r\n    html += `<div class=\"splide__track\">`;\r\n    html += `<${ listTag } class=\"splide__list\">`;\r\n\r\n    html += this.renderSlides();\r\n\r\n    html += `</${ listTag }>`;\r\n    html += `</div>`; // .track\r\n\r\n    html += afterTrack || '';\r\n\r\n    if (slider) {\r\n      html += `</div>`;\r\n      html += afterSlider || '';\r\n    }\r\n\r\n    html += `</div>`; // .splide\r\n\r\n    return html;\r\n  }\r\n}\r\n","export const EVENT_MOUNTED = 'mounted';\r\nexport const EVENT_READY = 'ready';\r\nexport const EVENT_MOVE = 'move';\r\nexport const EVENT_MOVED = 'moved';\r\nexport const EVENT_CLICK = 'click';\r\nexport const EVENT_ACTIVE = 'active';\r\nexport const EVENT_INACTIVE = 'inactive';\r\nexport const EVENT_VISIBLE = 'visible';\r\nexport const EVENT_HIDDEN = 'hidden';\r\nexport const EVENT_REFRESH = 'refresh';\r\nexport const EVENT_UPDATED = 'updated';\r\nexport const EVENT_RESIZE = 'resize';\r\nexport const EVENT_RESIZED = 'resized';\r\nexport const EVENT_DRAG = 'drag';\r\nexport const EVENT_DRAGGING = 'dragging';\r\nexport const EVENT_DRAGGED = 'dragged';\r\nexport const EVENT_SCROLL = 'scroll';\r\nexport const EVENT_SCROLLING = 'scrolling';\r\nexport const EVENT_SCROLLED = 'scrolled';\r\nexport const EVENT_OVERFLOW = 'overflow';\r\nexport const EVENT_DESTROY = 'destroy';\r\nexport const EVENT_ARROWS_MOUNTED = 'arrows:mounted';\r\nexport const EVENT_ARROWS_UPDATED = 'arrows:updated';\r\nexport const EVENT_PAGINATION_MOUNTED = 'pagination:mounted';\r\nexport const EVENT_PAGINATION_UPDATED = 'pagination:updated';\r\nexport const EVENT_NAVIGATION_MOUNTED = 'navigation:mounted';\r\nexport const EVENT_AUTOPLAY_PLAY = 'autoplay:play';\r\nexport const EVENT_AUTOPLAY_PLAYING = 'autoplay:playing';\r\nexport const EVENT_AUTOPLAY_PAUSE = 'autoplay:pause';\r\nexport const EVENT_LAZYLOAD_LOADED = 'lazyload:loaded';\r\nexport const EVENT_LAZYLOAD_ERROR = 'lazyload:error';\r\n\r\n/** @internal */\r\nexport const EVENT_SLIDE_KEYDOWN = '_sk';\r\nexport const EVENT_SHIFTED = '_sh';\r\nexport const EVENT_END_INDEX_CHANGED = '_ei';\r\n","/**\r\n * The type for the regular slider.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport const SLIDE = 'slide';\r\n\r\n/**\r\n * The type for the carousel slider.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport const LOOP = 'loop';\r\n\r\n/**\r\n * The type for the fade slider that can not have multiple slides in a page.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport const FADE = 'fade';\r\n","export const CLASS_RENDERED = 'is-rendered';\r\n","/**\r\n * The namespace for SVG elements.\r\n */\r\nexport const XML_NAME_SPACE = 'http://www.w3.org/2000/svg';\r\n\r\n/**\r\n * The arrow path.\r\n */\r\nexport const PATH = 'm15.5 0.932-4.3 4.38 14.5 14.6-14.5 14.5 4.3 4.4 14.6-14.6 4.4-4.3-4.4-4.4-14.6-14.6z';\r\n\r\n/**\r\n * SVG width and height.\r\n */\r\nexport const SIZE = 40;\r\n"],"names":["apply","func","args","bind","typeOf","type","subject","isObject","isArray","Array","isString","toArray","value","push","array","items","arrayProto","prototype","slice","arrayLike","start","end","call","assign","Object","ownKeys","keys","forOwn","object","iteratee","right","reverse","forEach","key","merge","sources","source","matches","elm","selector","ownerDocument","defaultView","window","HTMLElement","e","child","parent","children2","children","filter","child2","firstElementChild","removeNode","nodes","node","parentNode","removeChild","unit","max","Math","camelToKebab","string","replace","toLowerCase","ids","ORIENTATION_MAP","width","left","x","X","Y","ArrowLeft","ArrowRight","Direction","Splide","Components","options","resolve","prop","axisOnly","direction","index","match","offset","replacement","charAt","toUpperCase","orient","PROJECT_CODE","CLASS_PREFIX","CLASS_ROOT","CLASS_SLIDE","CLASS_CLONE","CLASS_ARROW","CLASS_PAGINATION","CLASS_ACTIVE","DEFAULTS","speed","perPage","easing","drag","interval","trimSpace","focusableNodes","classes","slide","clone","arrows","arrow","prev","next","pagination","page","spinner","i18n","first","last","slideX","pageX","play","pause","carousel","select","slideLabel","reducedMotion","rewindSpeed","autoplay","RENDERER_DEFAULT_CONFIG","listTag","slideTag","Style","styles","id","constructor","this","rule","breakpoint","selectors","build","let","css","default","buildSelectors","sort","n","m","mediaQuery","trim","assert","condition","message","Error","clean","splide","on","event","root","clones","querySelectorAll","contents","slides","config","breakpoints","defaults","prefix","padStart","length","init","parseBreakpoints","initSlides","registerRootStyles","registerTrackStyles","registerSlideStyles","registerListStyles","map","content","html","attrs","cover","class","style","buildStyles","isLoop","generateClones","cssPadding","cssTrackHeight","buildTranslate","cssSlideHeight","cssAspectRatio","cssSlideWidth","gap","values","cssOffsetClones","cssOffsetGaps","isCenter","buildCssValue","cssOffsetCenter","Boolean","join","percent","cloneCount","getCloneCount","isFixedWidth","parseCssValue","padding","height","isVertical","cssHeight","autoWidth","fixedWidth","cssSlideSize","fixedHeight","autoHeight","heightRatio","parseFloat","focus","buildClasses","isNavigation","hidden","buildAttrs","attr","renderSlides","tag","lazyLoad","src","background","count","unshift","flickMaxPages","renderArrows","renderArrow","ariaLabel","arrowPath","rootClass","beforeTrack","afterTrack","slider","beforeSlider","afterSlider"],"mappings":"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"}